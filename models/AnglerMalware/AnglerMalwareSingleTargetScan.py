import pandas as pd
import joblib
import pefile  # For extracting imports from a PE file
import re

def extract_imports_from_exe(file_path):
    """
    Extracts imports from a PE executable file.
    
    Args:
        file_path: Path to the .exe file.

    Returns:
        A string of imports separated by '|', or None if imports cannot be extracted.
    """
    try:
        pe = pefile.PE(file_path)
        imports = []

        # Iterate over the imported DLLs and their functions
        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll_name = entry.dll.decode('utf-8', errors='ignore')
                for func in entry.imports:
                    if func.name:
                        function_name = func.name.decode('utf-8', errors='ignore')
                        imports.append(f"{dll_name}:{function_name}")
        
        return "|".join(imports)
    except Exception as e:
        print(f"Error extracting imports from {file_path}: {e}")
        return None


def preprocess_imports(imports_str):
    """
    Preprocesses the extracted imports to match the format used during training.

    Args:
        imports_str: The raw imports string separated by '|'.

    Returns:
        A preprocessed string of imports.
    """
    imports_split = imports_str.split("|")
    cleaned_imports = []

    for imp in imports_split:
        imp = imp.strip()
        if not imp:
            continue
        
        # Split DLL and function name
        module_part, sep, func_part = imp.partition(":")
        if module_part.lower().endswith(".dll"):
            if func_part.strip():
                cleaned_imports.append(func_part.strip())
        else:
            cleaned_imports.append(imp)
    
    return " ".join(cleaned_imports)


def predict_specific_exe(file_path, model_file, vectorizer_file):
    """
    Predicts whether a specific executable file is malicious or benign.

    Args:
        file_path: Path to the .exe file.
        model_file: Path to the saved model file.
        vectorizer_file: Path to the saved vectorizer file.

    Returns:
        The prediction (0 = benign, 1 = malicious).
    """
    # Extract imports from the executable
    imports_str = extract_imports_from_exe(file_path)
    if not imports_str:
        print(f"No imports found in {file_path}. Cannot make a prediction.")
        return None

    # Preprocess the imports
    preprocessed_imports = preprocess_imports(imports_str)

    # Load the trained model and vectorizer
    clf = joblib.load(model_file)
    vectorizer = joblib.load(vectorizer_file)

    # Transform the imports using the vectorizer
    X_test = vectorizer.transform([preprocessed_imports])

    # Make a prediction
    prediction = clf.predict(X_test)[0]
    print(f"Prediction for {file_path}: {'Malicious' if prediction == 1 else 'Benign'}")
    return prediction


if __name__ == "__main__":
    # Example usage
    exe_file_path = "testdata/Lockdown Browser.txt"  # Replace with the path to your .exe file
    model_file = "dt_model.joblib"  # Path to your trained model
    vectorizer_file = "dt_vectorizer.joblib"  # Path to your saved vectorizer

    predict_specific_exe(
        file_path=exe_file_path,
        model_file=model_file,
        vectorizer_file=vectorizer_file
    )
