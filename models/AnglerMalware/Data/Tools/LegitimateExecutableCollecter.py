import os
import sys
import csv
import hashlib
import pefile
import stat
import string

def get_all_drives():
    """
    Return a list of valid drive letters on Windows, e.g. ['C:\\', 'D:\\'].
    For non-Windows systems, you might adapt this to check mount points.
    """
    drives = []
    if os.name == 'nt':
        # Check all possible drive letters
        for letter in string.ascii_uppercase:
            drive = f"{letter}:\\"
            if os.path.exists(drive):
                drives.append(drive)
    else:
        # On Linux/macOS, adapt this to your mount points or root paths
        drives = ['/']  # Typically you'd start from root in *nix
    return drives

def extract_imports(pe):
    """
    Extract imported DLL and function names from a PE file object.
    """
    imports = []
    if hasattr(pe, "DIRECTORY_ENTRY_IMPORT"):
        for entry in pe.DIRECTORY_ENTRY_IMPORT:
            dll_name = entry.dll.decode("utf-8", errors="ignore")
            for imp in entry.imports:
                if imp.name:
                    func_name = imp.name.decode("utf-8", errors="ignore")
                else:
                    # Some imports may not have a name (import by ordinal)
                    func_name = f"Ordinal({imp.ordinal})"
                imports.append(f"{dll_name}:{func_name}")
    return imports

def get_sha256(file_path):
    """
    Compute the SHA256 hash of a file on disk.
    """
    sha256_hash = hashlib.sha256()
    with open(file_path, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            sha256_hash.update(chunk)
    return sha256_hash.hexdigest()

def process_exe(file_path, csv_writer):
    """
    Load the .exe into memory, parse with pefile, compute SHA256,
    and write the results to CSV.
    """
    try:
        # Read into memory to avoid file-handle issues
        with open(file_path, "rb") as f:
            exe_data = f.read()

        # Parse the PE structure from memory
        pe = pefile.PE(data=exe_data)
        imports = extract_imports(pe)

        # Compute SHA-256 from the file on disk
        sha256_val = get_sha256(file_path)

        csv_writer.writerow([file_path, sha256_val, "|".join(imports)])
    except Exception as e:
        print(f"[!] Failed to process {file_path}: {e}")

def walk_and_process_exes(drive, csv_writer):
    """
    Recursively walk a drive (or path) and look for .exe files.
    For each .exe, process with pefile and write results to CSV.
    """
    # List of directories to ignore
    ignore_dirs = {'Windows'}

    for root, dirs, files in os.walk(drive, topdown=True, followlinks=False):
        # Remove directories to ignore from the list of directories to traverse
        dirs[:] = [d for d in dirs if d not in ignore_dirs]

        for file in files:
            if file.lower().endswith(".exe"):
                full_path = os.path.join(root, file)
                # Some files might be locked or inaccessible, handle exceptions
                if os.path.isfile(full_path):
                    process_exe(full_path, csv_writer)

def main():
    output_csv = "exe_pe_analysis.csv"
    # If you'd like to start fresh each time, remove old CSV:
    if os.path.exists(output_csv):
        os.remove(output_csv)

    # Gather all drives
    drives = get_all_drives()
    print(f"[*] Found drives: {drives}")

    # Open CSV in append mode (or "w" if you prefer)
    with open(output_csv, "w", newline="", encoding="utf-8") as csvfile:
        csv_writer = csv.writer(csvfile)
        # Write header
        csv_writer.writerow(["FilePath", "SHA256", "Imports"])

        for drive in drives:
            print(f"[+] Scanning drive: {drive}")
            # Recursively process .exe files
            walk_and_process_exes(drive, csv_writer)

    print(f"\n[+] Done. Results stored in {output_csv}")

if __name__ == "__main__":
    main()